@using System.Drawing
@using System.Globalization;
@using WebCalendar.Client.Code;

@inject IJSRuntime JSRuntime
@inject CalendarStorageService CalendarStorageService

<div class="p-4 max-w-4xl mx-auto">
    <div class="flex justify-between items-center mb-4">
        <button @onclick="() => ChangeMonth(-1)"
                class="w-12 h-12 flex items-center justify-center rounded-full bg-white/50 dark:bg-black/30 dark:text-white
               button-style">
            <span class="text-2xl relative -top-[1px] leading-none">←</span>
        </button>

        <h2 class="text-xl font-bold dark:text-white">
            @_currentDate.ToString("MMMM yyyy", CultureInfo.CurrentCulture)
        </h2>

        <button @onclick="() => ChangeMonth(1)"
                class="w-12 h-12 flex items-center justify-center rounded-full bg-white/50 dark:bg-black/30 dark:text-white
               button-style">
            <span class="text-2xl relative -top-[1px] leading-none">→</span>
        </button>

    </div>

    <div class="grid grid-cols-7 text-center font-semibold text-gray-600 dark:text-gray-300 mb-2">
        @foreach (var dayName in _dayNames)
        {
            <div>@dayName</div>
        }
    </div>

    <div class="grid grid-cols-7 gap-2">
        @foreach (var day in _days)
        {
            var paletteId = $"palette-{day.Date:yyyyMMdd}";
            var buttonId = $"daybtn-{day.Date:yyyyMMdd}";

            <div class="relative">
                <div id="@buttonId"
                     @onclick="@(() => OpenColorPicker(day))"
                     class="@GetDayClass(day) select-none"
                     style="background-color:@GetDayColor(day)">
                    @if (day.Date != DateTime.MinValue)
                    {
                        @day.Date.Day
                    }
                </div>

                @if (day.Date != DateTime.MinValue && SelectedDay == day)
                {
                    <div id="@paletteId"
                         class="absolute left-1/2 -translate-x-1/2 mt-2 z-50 flex gap-2 p-2 rounded-xl shadow-lg
            border border-gray-200 dark:border-gray-700
            bg-white dark:bg-gray-900
            transition-opacity duration-300
            @(PaletteReady ? "opacity-100" : "opacity-0 pointer-events-none")">
                        @foreach (var color in PaletteColors)
                        {
                            <button class="w-6 h-6 rounded-full border-2 border-white shadow hover:scale-110 transition-transform focus:outline-none"
                                    style="background:rgba(@color.R,@color.G,@color.B,1)"
                                    @onclick="() => OnPaletteColorSelected(day, color)">
                            </button>
                        }
                    </div>
                }
            </div>
        }
    </div>
</div>


@code {
    [Parameter] public bool IsDarkMode { get; set; }

    private bool _initialized;
    private bool PaletteReady { get; set; } = false;

    private IJSObjectReference? _paletteClickHandler;

    private string _opacityLight = "0.5";
    private string _opacityDark = "0.3";

    private DateTime _currentDate = DateTime.Today;

    private List<string> _dayNames = CultureInfo.CurrentCulture.DateTimeFormat.AbbreviatedDayNames
        .Skip(1).Concat(CultureInfo.CurrentCulture.DateTimeFormat.AbbreviatedDayNames.Take(1)).ToList();

    private List<CalendarDay> _days = new();

    private CalendarDay? SelectedDay { get; set; }

    private List<Color> PaletteColors => new List<Color> {
        Color.FromArgb(255, 239, 68, 68),   // #ef4444
        Color.FromArgb(255, 245, 158, 66),  // #f59e42
        Color.FromArgb(255, 34, 197, 94),   // #22c55e
        Color.FromArgb(255, 59, 130, 246),  // #3b82f6
        Color.FromArgb(255, 139, 92, 246),  // #8b5cf6
        Color.FromArgb(255, 236, 72, 153),  // #ec4899
        Color.FromArgb(255, 229, 231, 235), // #e5e7eb
        GetDefaultColor() };

    private Color GetDefaultColor()
    {
        return IsDarkMode ? Color.Black : Color.White;
    }

    [JSInvokable]
    public async void HidePalette()
    {
        SelectedDay = null;
        PaletteReady = false;

        await DisposePaletteHandler();

        StateHasChanged();
    }

    private async Task DisposePaletteHandler()
    {
        if (_paletteClickHandler != null)
        {
            await _paletteClickHandler.InvokeVoidAsync("dispose");
            _paletteClickHandler = null;
        }
    }


    private async Task OnPaletteColorSelected(CalendarDay day, Color color)
    {
        day.Color = color;
        SelectedDay = null;
        PaletteReady = false;

        await DisposePaletteHandler();

        if (color != GetDefaultColor())
        {
            await CalendarStorageService.SaveDay(day);
        }
        else
        {
            await CalendarStorageService.DeleteDay(day);
        }

        StateHasChanged();
    }

    private async Task OpenColorPicker(CalendarDay day)
    {
        if (day.Date == DateTime.MinValue) return;
        SelectedDay = day;
        PaletteReady = false;
        StateHasChanged();

        await Task.Delay(10);

        var paletteId = $"palette-{day.Date:yyyyMMdd}";
        var buttonId = $"daybtn-{day.Date:yyyyMMdd}";
        await JSRuntime.InvokeVoidAsync("adjustPalettePosition", paletteId, buttonId);

        PaletteReady = true;
        StateHasChanged();

        // Регистрируем обработчик клика вне палитры
        var dotNetRef = DotNetObjectReference.Create(this);
        _paletteClickHandler = await JSRuntime.InvokeAsync<IJSObjectReference>("registerPaletteOutsideClick", paletteId, dotNetRef);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_initialized)
        {
            _initialized = true;

            await GenerateCalendar(); // теперь можно безопасно вызывать JS
            StateHasChanged(); // перерендерим, если нужно
        }
    }


    protected override void OnParametersSet()
    {
        SetInitialColors();
    }

    private async Task LoadDaysFromLocalStorage()
    {
        var savedDays = await CalendarStorageService.LoadDays();

        foreach (var savedDay in savedDays)
        {
            var day = _days.FirstOrDefault(d => d.Date.Date == savedDay.Date.Date);

            if (day != null)
            {
                day.Color = savedDay.Color;
            }
        }

    }

    private async Task GenerateCalendar()
    {
        var firstDayOfMonth = new DateTime(_currentDate.Year, _currentDate.Month, 1);
        var daysInMonth = DateTime.DaysInMonth(_currentDate.Year, _currentDate.Month);

        // Сдвиг дней: понедельник = 0, ..., воскресенье = 6
        int startOffset = ((int)firstDayOfMonth.DayOfWeek + 6) % 7;

        _days = new();

        // Добавляем пустые "заполнители" до начала месяца
        for (int i = 0; i < startOffset; i++)
        {
            _days.Add(new CalendarDay
                {
                    Date = DateTime.MinValue,
                    IsMarked = false,
                    Color = Color.Transparent
                });
        }

        // Добавляем реальные дни
        for (int i = 1; i <= daysInMonth; i++)
        {
            _days.Add(new CalendarDay
                {
                    Date = new DateTime(_currentDate.Year, _currentDate.Month, i),
                    Color = IsDarkMode ? Color.Black : Color.White,
                    IsMarked = true
                });
        }

        await LoadDaysFromLocalStorage();

        StateHasChanged();
    }

    private void SetInitialColors()
    {
        foreach (var day in _days)
        {
            if (day.Color == Color.Black || day.Color == Color.White)
            {
                day.Color = GetDefaultColor();
            }

            day.IsMarked = true;
        }
    }

    private string GetDayClass(CalendarDay day)
    {
        if (day.Date == DateTime.MinValue)
            return ""; // пустая ячейка

        var baseClass = "rounded-2xl p-4 cursor-pointer button-style text-center dark:text-white";

        if (day.Date.Date == DateTime.Today.Date &&
            day.Date.Month == DateTime.Today.Month &&
            day.Date.Year == DateTime.Today.Year)
        {
            baseClass += " ring-2 ring-red-400";
        }

        return baseClass;
    }

    private string GetDayColor(CalendarDay day)
    {
        if (day.Date == DateTime.MinValue)
            return "transparent";

        var alpha = IsDarkMode ? _opacityDark : _opacityLight;

        return $"rgba({day.Color.R},{day.Color.G},{day.Color.B},{alpha})";
    }

    private async Task ChangeMonth(int offset)
    {
        _currentDate = _currentDate.AddMonths(offset);
        await GenerateCalendar();
    }
}
